{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to NixPHP \u2014 a minimalist, modern PHP microframework.</p> <p>NixPHP is built for developers who want:</p> <ul> <li>Full control over their application's structure</li> <li>Minimal dependencies and maximum flexibility</li> <li>Native PHP strengths combined with modern standards (PSR-3, PSR-4, PSR-7, PSR-11, PSR-18)</li> </ul> <p>It provides essential features like routing, controller dispatching, view rendering, database access, session handling, and smart response handling \u2014 without unnecessary overhead.</p> <p>Use NixPHP as a lightweight foundation for APIs, web applications, or any PHP project that values clarity, speed, and simplicity.</p>"},{"location":"best_practices/","title":"Best Practices","text":"<p>NixPHP gives you a lot of flexibility and freedom. Following a few simple best practices can help keep your project clean, scalable, and maintainable.</p>"},{"location":"best_practices/#keep-controllers-thin","title":"Keep Controllers Thin","text":"<p>Controllers should focus on handling HTTP-specific logic: Receiving requests, calling services, and returning responses.</p> <p>Move heavy business logic into separate service classes.</p> <p>Example:</p> <pre><code>// Good: Controller is only responsible for flow control\npublic function create()\n{\n    $productService = app()-&gt;container()-&gt;get('productService');\n    $product = $productService-&gt;create($_POST);\n\n    return redirect('/products');\n}\n</code></pre>"},{"location":"best_practices/#use-services-for-business-logic","title":"Use Services for Business Logic","text":"<p>Complex operations (e.g., creating users, processing orders) should be done inside dedicated service classes.</p> <p>Example:</p> <pre><code>namespace App\\Services;\n\nclass ProductService\n{\n    public function create(array $data)\n    {\n        // Validation, database operations, etc.\n    }\n}\n</code></pre> <ul> <li>Keeps your code modular.</li> <li>Makes testing and maintenance easier.</li> </ul>"},{"location":"best_practices/#use-events-to-decouple-features","title":"Use Events to Decouple Features","text":"<p>Instead of hardcoding everything, use <code>event()-&gt;dispatch()</code> and <code>event()-&gt;listen()</code> to make your application more flexible and extensible.</p> <p>Example:</p> <pre><code>event()-&gt;dispatch('user.registered', $user);\n</code></pre> <ul> <li>Other parts of your app can react to events without changing the core code.</li> </ul>"},{"location":"best_practices/#handle-errors-cleanly","title":"Handle Errors Cleanly","text":"<p>Always use the <code>abort()</code> helper when something goes wrong.</p> <p>Example:</p> <pre><code>$product = database()-&gt;find('products', $id);\n\nif (!$product) {\n    abort(404, 'Product not found.');\n}\n</code></pre> <ul> <li>Makes sure that the user sees proper error pages.</li> <li>Keeps your controller flow clean and predictable.</li> </ul>"},{"location":"best_practices/#organize-config-and-services","title":"Organize Config and Services","text":"<ul> <li>Keep all important configuration in <code>app/config.php</code>.</li> <li>Use the container (<code>app()-&gt;container()</code>) to manage your services centrally.</li> <li>Prefer string keys like <code>'productService'</code>, <code>'userRepository'</code> instead of full class names.</li> </ul> <p>Good example:</p> <pre><code>app()-&gt;container()-&gt;set('userRepository', function () {\n    return new \\App\\Repositories\\UserRepository();\n});\n</code></pre>"},{"location":"best_practices/#write-custom-helpers-if-needed","title":"Write Custom Helpers if Needed","text":"<p>If you find yourself repeating common tasks (like escaping output or creating responses), feel free to add your own global helpers.</p> <p>NixPHP encourages building small, reusable tools that fit your needs.</p> <p>Example:</p> <pre><code>use function NixPHP\\s;\n\n&lt;h1&gt;Hello, &lt;?= s($user-&gt;name) ?&gt;!&lt;/h1&gt;\n</code></pre>"},{"location":"best_practices/#summary","title":"Summary","text":"<ul> <li>Thin Controllers \u2192 Heavy Services</li> <li>Use Events for extension and decoupling</li> <li>Handle errors consistently with <code>abort()</code></li> <li>Manage all services via the container</li> <li>Organize config cleanly</li> <li>Build small reusable helpers when needed</li> </ul> <p>NixPHP gives you the freedom to structure your app your way \u2014 following these best practices will help you build clean and scalable projects.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>NixPHP provides a simple yet flexible configuration system based on <code>.env</code> files, a lightweight environment service, and a powerful configuration loader.</p> <p>You can easily manage different settings for local development, staging, and production environments.</p>"},{"location":"configuration/#using-env-files","title":"Using <code>.env</code> Files","text":"<p>NixPHP can automatically load environment variables from a <code>.env</code> file placed in the project root.</p> <pre><code>APP_ENV=local\nAPP_DEBUG=true\nDB_HOST=localhost\nDB_USER=root\nDB_PASS=secret\n</code></pre> <ul> <li>Each line defines a key-value pair.</li> <li>Lines starting with <code>#</code> are treated as comments.</li> <li>Values can be referenced inside configuration files or application code.</li> </ul> <p>The <code>.env</code> file is loaded automatically during the bootstrap phase.</p>"},{"location":"configuration/#accessing-environment-variables","title":"Accessing Environment Variables","text":"<p>You can access environment variables anywhere in your code using the <code>env()</code> helper:</p> <pre><code>$host = env('DB_HOST', 'localhost');\n</code></pre> <ul> <li>The first argument is the environment variable name.</li> <li>The second argument is an optional default value if the variable is not set.</li> </ul>"},{"location":"configuration/#environment-detection","title":"Environment Detection","text":"<p>NixPHP includes a small <code>Environment</code> service to detect the current application environment.</p> <p>It supports four predefined environments:</p> Name Typical Usage <code>local</code> Local development machine <code>staging</code> Preview system before going live <code>production</code> Live/real system <code>testing</code> Automated test environment <p>You can check the environment using helper methods:</p> <pre><code>if (env()-&gt;isLocal()) {\n    ini_set('display_errors', '1');\n}\n\nif (env()-&gt;isProduction()) {\n    ini_set('display_errors', '0');\n}\n</code></pre> <p>Available methods:</p> <ul> <li><code>isLocal()</code></li> <li><code>isStaging()</code></li> <li><code>isProduction()</code></li> <li><code>isTesting()</code></li> </ul>"},{"location":"configuration/#application-configuration","title":"Application Configuration","text":"<p>NixPHP loads application settings through a lightweight <code>Config</code> class.</p> <p>You can organize configuration into arrays and load them through the container.</p> <p>A typical configuration file might look like this:</p> <pre><code>return [\n    'name' =&gt; 'My App',\n    'api' =&gt; [\n        'key' =&gt; 'ENV:API_KEY',\n        'url' =&gt; 'https://api.example.com',\n    ],\n];\n</code></pre> <ul> <li>Values prefixed with <code>ENV:</code> will be automatically resolved from environment variables.</li> <li>Nested arrays are supported.</li> </ul>"},{"location":"configuration/#accessing-configuration-values","title":"Accessing Configuration Values","text":"<p>You can access configuration values using the <code>config()</code> helper:</p> <pre><code>// Get a full configuration array\n$fullConfig = config();\n\n// Get a single config value\n$appName = config('name');\n\n// Access nested configuration using \"namespace\" syntax\n$apiKey = config('api:key');\n\n// Provide a default value if the key is not found\n$apiUrl = config('api:url', 'https://default.example.com');\n</code></pre> <ul> <li>If the key contains a colon <code>:</code>, it is treated as a namespace separator.</li> <li>Nested configuration is traversed automatically.</li> </ul>"},{"location":"configuration/#internals-how-configuration-works","title":"Internals: How Configuration Works","text":"<p>The <code>Config</code> class:</p> <ul> <li>Accepts an array on construction.</li> <li>Resolves all <code>ENV:</code> placeholders recursively.</li> <li>Provides <code>get($key, $default)</code> and <code>all()</code> methods for access.</li> <li>Supports simple \"namespace\" lookups via <code>:</code> syntax.</li> </ul> <p>The <code>config()</code> helper fetches the instance from the container and allows quick access anywhere in your code.</p>"},{"location":"configuration/#example-setting-error-display-based-on-environment","title":"Example: Setting Error Display Based on Environment","text":"<p>You can configure error reporting inside <code>bootstrap.php</code> depending on the current environment:</p> <pre><code>if (env()-&gt;isProduction()) {\n    ini_set('display_errors', '0');\n    error_reporting(E_ALL &amp; ~E_DEPRECATED &amp; ~E_NOTICE);\n} else {\n    ini_set('display_errors', '1');\n    error_reporting(E_ALL);\n}\n</code></pre>"},{"location":"configuration/#summary","title":"Summary","text":"<ul> <li>Use <code>.env</code> files to store environment-specific settings.</li> <li>Use the <code>env()</code> helper to access variables with optional default values.</li> <li>The <code>Environment</code> service allows checking the current environment cleanly.</li> <li>Use configuration arrays with optional <code>ENV:</code> references.</li> <li>Access configuration values easily with the <code>config()</code> helper.</li> <li>Configuration supports nested access via \"namespace\" keys (e.g., <code>api:key</code>).</li> </ul>"},{"location":"controllers/","title":"Controllers","text":"<p>In NixPHP, a controller is anything that handles an incoming HTTP request. This can be either:</p> <ul> <li>a controller class method, or</li> <li>an anonymous function (Closure).</li> </ul> <p>This section explains both options.</p>"},{"location":"controllers/#controller-classes","title":"Controller Classes","text":"<p>You can define a controller as a simple PHP class with public methods.</p> <pre><code>namespace App\\Controllers;\n\nuse function NixPHP\\render;\n\nclass HelloController\n{\n    public function index()\n    {\n        return render('hello', ['name' =&gt; 'World']);\n    }\n}\n</code></pre> <ul> <li>Namespace: Controllers are typically placed in <code>App\\Controllers</code>.</li> <li>Method: The method name should match the one you defined in your route.</li> <li>Return: The method must return a <code>Psr\\Http\\Message\\ResponseInterface</code>.</li> </ul>"},{"location":"controllers/#defining-a-route-to-a-controller","title":"Defining a Route to a Controller","text":"<pre><code>// app/routes.php\n\nroute()-&gt;add('GET', '/hello', [HelloController::class, 'index']);\n</code></pre> <p>When a user visits <code>/hello</code>, NixPHP:</p> <ol> <li>Instantiates the <code>HelloController</code>.</li> <li>Calls the <code>index()</code> method.</li> <li>Sends the returned Response to the browser.</li> </ol>"},{"location":"controllers/#closures-as-controllers","title":"Closures as Controllers","text":"<p>Instead of using a class, you can define a route directly with a Closure:</p> <pre><code>// app/routes.php\n\nuse function NixPHP\\response;\n\nroute()-&gt;add('GET', '/ping', function () {\n    return response('Pong!');\n});\n</code></pre> <ul> <li>Closures must also return a <code>Psr\\Http\\Message\\ResponseInterface</code>.</li> <li>Useful for small endpoints, quick APIs, or simple prototyping.</li> </ul>"},{"location":"controllers/#route-parameters","title":"Route Parameters","text":"<p>If your route contains dynamic segments, NixPHP passes them automatically to your handler:</p> <pre><code>// app/routes.php\n\nroute()-&gt;add('GET', '/user/{id}', [UserController::class, 'profile']);\n</code></pre> <p>Controller example:</p> <pre><code>namespace App\\Controllers;\n\nuse function NixPHP\\render;\n\nclass UserController\n{\n    public function profile($id)\n    {\n        return render('user-profile', ['id' =&gt; $id]);\n    }\n}\n</code></pre> <p>Closure example:</p> <pre><code>route()-&gt;add('GET', '/order/{orderId}', function ($orderId) {\n    return response(\"Order ID: {$orderId}\");\n});\n</code></pre> <ul> <li>Parameters are injected based on their order.</li> <li>Parameter names in methods or closures do not have to match the URL placeholders \u2014 only the position matters.</li> </ul>"},{"location":"controllers/#returning-responses","title":"Returning Responses","text":"<p>Every handler (whether class method or closure) must return a <code>Psr\\Http\\Message\\ResponseInterface</code>.</p> <p>Helper functions available:</p> Helper Description <code>render($template, $variables = [])</code> Renders a view and returns an HTML Response <code>response($content)</code> Creates a basic text response"},{"location":"controllers/#when-to-use-controller-classes-vs-closures","title":"When to use Controller Classes vs. Closures","text":"Use Case Recommended Approach Larger, structured application logic Controller class Handling multiple related routes (e.g., UserController, PostController) Controller class Small, isolated endpoints Closure Quick API prototypes or testing Closure You want to group logic and share methods Controller class You just need a quick one-off response Closure"},{"location":"database/","title":"Database","text":"<p>NixPHP provides a simple and flexible way to work with databases using native PDO.</p> <p>You are free to build your own database layer or plug in any external ORM if needed.</p>"},{"location":"database/#accessing-the-database","title":"Accessing the Database","text":"<p>The global <code>database()</code> helper gives you access to the PDO instance:</p> <pre><code>use function NixPHP\\database;\n\n$pdo = database();\n</code></pre> <p>You can use standard PDO methods:</p> <pre><code>$stmt = database()-&gt;query('SELECT * FROM users');\n$users = $stmt-&gt;fetchAll();\n</code></pre>"},{"location":"database/#database-configuration","title":"Database Configuration","text":"<p>Database settings are stored inside your application's <code>app/config.php</code> file under the <code>database</code> key.</p> <p>Example <code>app/config.php</code>:</p> <pre><code>&lt;?php\n\nreturn [\n    'database' =&gt; [\n        'driver'   =&gt; 'mysql',\n        'host'     =&gt; '127.0.0.1',\n        'database' =&gt; 'NixPHP',\n        'username' =&gt; 'root',\n        'password' =&gt; 'root',\n        'charset'  =&gt; 'utf8mb4',\n    ]\n];\n</code></pre> <p>NixPHP builds the PDO connection dynamically based on this configuration.</p> <ul> <li><code>driver</code>: e.g., <code>mysql</code>, <code>pgsql</code>, <code>sqlite</code></li> <li><code>host</code>: database server hostname or IP</li> <li><code>database</code>: database name</li> <li><code>username</code>: database user</li> <li><code>password</code>: database password</li> <li><code>charset</code>: character set (default <code>utf8mb4</code>)</li> </ul>"},{"location":"database/#example-prepared-statements","title":"Example: Prepared Statements","text":"<p>You can use prepared statements with bound parameters:</p> <pre><code>$stmt = database()-&gt;prepare('SELECT * FROM users WHERE id = :id');\n$stmt-&gt;execute(['id' =&gt; 1]);\n$user = $stmt-&gt;fetch();\n</code></pre> <ul> <li>Prepared statements help protect against SQL injection.</li> <li>Use named parameters (<code>:name</code>) or question marks (<code>?</code>).</li> </ul>"},{"location":"database/#using-transactions","title":"Using Transactions","text":"<p>Transactions are fully supported:</p> <pre><code>$pdo = database();\n$pdo-&gt;beginTransaction();\n\ntry {\n    $pdo-&gt;exec('INSERT INTO users (name) VALUES (\"John\")');\n    $pdo-&gt;exec('INSERT INTO profiles (user_id) VALUES (LAST_INSERT_ID())');\n    $pdo-&gt;commit();\n} catch (\\Exception $e) {\n    $pdo-&gt;rollBack();\n    throw $e;\n}\n</code></pre> <ul> <li>Transactions ensure atomic database operations.</li> <li>Always use try/catch blocks when working with transactions.</li> </ul>"},{"location":"database/#summary","title":"Summary","text":"<ul> <li>Access the database via the <code>database()</code> helper.</li> <li>Configure database settings in <code>app/config.php</code> under the <code>database</code> key.</li> <li>NixPHP uses native PDO for maximum flexibility.</li> <li>You can integrate any external ORM if needed (e.g., Eloquent, Doctrine, etc.).</li> </ul>"},{"location":"dependency_injection/","title":"Dependency Injection","text":"<p>NixPHP provides a simple and flexible PSR-11 compliant container to manage your services and dependencies.</p> <p>However, NixPHP does not automatically inject constructor parameters. You manually retrieve and manage your dependencies.</p>"},{"location":"dependency_injection/#the-container","title":"The Container","text":"<p>The application container is accessible globally via the <code>app()-&gt;container()</code> helper.</p> <pre><code>use function NixPHP\\app;\n\n$container = app()-&gt;container();\n</code></pre> <p>The container follows the PSR-11 <code>ContainerInterface</code> standard.</p>"},{"location":"dependency_injection/#registering-services","title":"Registering Services","text":"<p>You can register services manually in the container, typically during application bootstrapping.</p> <p>Example: Register a custom service:</p> <pre><code>app()-&gt;container()-&gt;set('productService', function () {\n    return new \\App\\Services\\ProductService();\n});\n</code></pre> <ul> <li>The service is registered under a simple string key (e.g., <code>'productService'</code>).</li> <li>The value is a closure that returns the instance.</li> <li>Services are created lazily and cached as singletons.</li> </ul>"},{"location":"dependency_injection/#using-services","title":"Using Services","text":"<p>You retrieve services manually from the container wherever you need them:</p> <pre><code>$productService = app()-&gt;container()-&gt;get('productService');\n\n$products = $productService-&gt;all();\n</code></pre> <p>There is no automatic constructor injection \u2014 you stay fully in control.</p>"},{"location":"dependency_injection/#example-productservice-in-a-controller","title":"Example: ProductService in a Controller","text":"<p>Register your service:</p> <pre><code>app()-&gt;container()-&gt;set('productService', function () {\n    return new \\App\\Services\\ProductService();\n});\n</code></pre> <p>Using it in a controller:</p> <pre><code>namespace App\\Controllers;\n\nuse function NixPHP\\app;\nuse function NixPHP\\render;\n\nclass ProductController\n{\n    public function list()\n    {\n        /** @var \\App\\Services\\ProductService $productService */\n        $productService = app()-&gt;container()-&gt;get('productService');\n\n        $products = $productService-&gt;all();\n\n        return render('products.list', ['products' =&gt; $products]);\n    }\n}\n</code></pre> <ul> <li>Fetch your services inside your methods.</li> <li>The service is automatically cached after the first retrieval.</li> </ul>"},{"location":"dependency_injection/#summary","title":"Summary","text":"<ul> <li>Access the container via <code>app()-&gt;container()</code>.</li> <li>Register services using string keys like <code>'productService'</code>, <code>'db'</code>, <code>'log'</code>, etc.</li> <li>Fetch services manually when needed.</li> <li>NixPHP does not automatically inject constructor arguments.</li> <li>Services behave as singletons by default (one instance per request).</li> </ul>"},{"location":"error_handling/","title":"Error Handling","text":"<p>NixPHP provides a simple and flexible mechanism for handling errors like 404 (Not Found) and 500 (Internal Server Error).</p> <p>By default, NixPHP uses internal error views located in the framework core. However, you can easily override these pages in your project.</p>"},{"location":"error_handling/#default-error-pages","title":"Default Error Pages","text":"<p>If an error occurs, NixPHP will:</p> <ol> <li>First check for a custom error page in your <code>app/views/errors/</code> directory.</li> <li>If no custom page exists, it falls back to the default built-in page.</li> </ol> <p>Built-in default pages exist for:</p> <ul> <li><code>404</code> \u2014 Not Found</li> <li><code>500</code> \u2014 Internal Server Error</li> </ul>"},{"location":"error_handling/#overriding-error-pages","title":"Overriding Error Pages","text":"<p>You can override any default error page by creating a file in your project at:</p> <ul> <li><code>app/views/errors/404.phtml</code></li> <li><code>app/views/errors/500.phtml</code></li> </ul> <p>Example: Custom 404 page:</p> <pre><code>&lt;?php use function NixPHP\\s; ?&gt;\n\n&lt;h1&gt;Page not found&lt;/h1&gt;\n&lt;p&gt;The page &lt;?= s($path) ?&gt; does not exist.&lt;/p&gt;\n</code></pre> <ul> <li>NixPHP automatically passes basic information like the requested path into your error view.</li> <li>Use the <code>s()</code> helper to safely escape any output.</li> </ul>"},{"location":"error_handling/#manually-aborting-requests","title":"Manually Aborting Requests","text":"<p>Sometimes you want to stop execution manually and send an error response. NixPHP provides the global <code>abort()</code> helper for this.</p> <pre><code>use function NixPHP\\abort;\n\nabort(404, 'The requested page was not found.');\n</code></pre> <ul> <li>Immediately stops execution.</li> <li>Sends the specified error page (e.g., 404, 500, etc.).</li> <li>Optionally pass a custom message.</li> </ul>"},{"location":"error_handling/#abort-function","title":"abort() Function","text":"<pre><code>function abort(int $statusCode = 404, string $message = ''): never\n{\n    $response = response(view('errors.' . $statusCode, [\n        'statusCode' =&gt; $statusCode,\n        'message' =&gt; s($message)\n    ]), 500);\n    send_response($response);\n    exit(0);\n}\n</code></pre> <ul> <li>Renders the error view from <code>app/views/errors/{$statusCode}.phtml</code>.</li> <li>Sends the response immediately and exits the application.</li> </ul>"},{"location":"error_handling/#handling-uncaught-exceptions","title":"Handling Uncaught Exceptions","text":"<p>If an uncaught exception occurs during request processing, NixPHP:</p> <ol> <li>Automatically catches the exception.</li> <li>Sends a <code>500 Internal Server Error</code> response.</li> <li>Uses the custom <code>app/views/errors/500.phtml</code> page if available.</li> </ol> <p>You don't have to manually catch exceptions unless you want to customize behavior.</p>"},{"location":"error_handling/#summary","title":"Summary","text":"<ul> <li>Create <code>app/views/errors/404.phtml</code> and/or <code>500.phtml</code> to override default error pages.</li> <li>Use the <code>abort()</code> helper to manually stop execution and send an error response.</li> <li>Uncaught exceptions automatically result in a 500 error page.</li> <li>Always use the <code>s()</code> helper to safely escape any dynamic content in error pages.</li> </ul>"},{"location":"events/","title":"Events","text":"<p>NixPHP includes a minimal yet powerful event system that allows you to hook into different parts of the application lifecycle.</p> <p>You can register listeners for specific events and execute custom code when those events are fired.</p>"},{"location":"events/#listening-for-events","title":"Listening for Events","text":"<p>You can listen to events by calling the <code>listen()</code> method via the <code>event()</code> helper.</p> <pre><code>use function NixPHP\\event;\n\nevent()-&gt;listen('user.registered', function ($user) {\n    // Handle the user registration event\n});\n</code></pre> <ul> <li>The first argument is the event name (a string).</li> <li>The second argument is a callable that will be executed when the event is dispatched.</li> </ul> <p>You can register multiple listeners for the same event.</p>"},{"location":"events/#dispatching-events","title":"Dispatching Events","text":"<p>You can fire (dispatch) events using the <code>dispatch()</code> method:</p> <pre><code>use function NixPHP\\event;\n\nevent()-&gt;dispatch('user.registered', $user);\n</code></pre> <ul> <li>The first argument is the event name.</li> <li>Additional arguments are passed to the listeners as parameters.</li> <li>All listener responses are collected into an array and returned.</li> </ul>"},{"location":"events/#example-custom-event-flow","title":"Example: Custom Event Flow","text":"<pre><code>use function NixPHP\\event;\n\n// Register a listener\nevent()-&gt;listen('product.created', function ($product) {\n    logger()-&gt;info('Product created: ' . $product-&gt;id);\n});\n\n// Dispatch the event\n$product = new Product();\nevent()-&gt;dispatch('product.created', $product);\n</code></pre>"},{"location":"events/#built-in-events","title":"Built-in Events","text":"<p>NixPHP fires several built-in events during the request lifecycle. You can hook into these to customize behavior without modifying core code.</p> Event Name When it fires Payload Typical Use <code>request.start</code> At the very beginning of <code>run()</code> or <code>forward()</code> <code>$_SERVER</code>, optional request objects Logging, preprocessing global request data <code>route.matching</code> Before route matching starts <code>$uri</code>, <code>$method</code> URL rewriting, redirections, special cases <code>route.matched</code> After a route has been found <code>$route</code> (array or object) Auth checks, feature toggles <code>route.not_found</code> If no route is found <code>$uri</code>, <code>$method</code> Custom 404 handling, statistics <code>controller.calling</code> Before calling the controller action <code>$controller</code>, <code>$method</code>, <code>$params</code> Controller overloading, parameter manipulation <code>controller.called</code> After the controller action returns <code>$controller</code>, <code>$method</code>, <code>$response</code> Post-processing, adding headers <code>response.sending</code> Before sending the response <code>$response</code> Caching, injecting headers, modifying output <code>request.end</code> At the very end after sending response Time measurement, memory usage Logging, performance analysis"},{"location":"events/#summary","title":"Summary","text":"<ul> <li>Use <code>event()-&gt;listen(event, callback)</code> to register event listeners.</li> <li>Use <code>event()-&gt;dispatch(event, payload...)</code> to fire events.</li> <li>Multiple listeners can be registered per event.</li> <li>NixPHP fires several built-in events you can hook into for full control over the request flow.</li> <li>Event responses are collected and returned as an array.</li> </ul>"},{"location":"external_libraries/","title":"Using External Libraries","text":"<p>NixPHP is designed to be minimal and flexible. You are free to integrate any external library you need without fighting against hidden internals.</p> <p>Thanks to the PSR-4 structure and Composer, adding new tools is simple and clean.</p>"},{"location":"external_libraries/#installing-packages","title":"Installing Packages","text":"<p>You can install any Composer package as usual:</p> <pre><code>composer require some/vendor-package\n</code></pre> <p>The package will be autoloaded automatically according to PSR-4 standards.</p>"},{"location":"external_libraries/#example-using-blade-templating","title":"Example: Using Blade Templating","text":"<p>Install Blade via Composer:</p> <pre><code>composer require jenssegers/blade\n</code></pre> <p>Create a simple service registration:</p> <pre><code>use Jenssegers\\Blade\\Blade;\n\napp()-&gt;container()-&gt;set('blade', function () {\n    return new Blade(BASE_PATH . '/app/views', BASE_PATH . '/storage/cache/views');\n});\n</code></pre> <p>Now you can use Blade inside your controllers:</p> <pre><code>$blade = app()-&gt;container()-&gt;get('blade');\n\nreturn response($blade-&gt;render('home', ['name' =&gt; 'World']));\n</code></pre>"},{"location":"external_libraries/#example-using-eloquent-orm","title":"Example: Using Eloquent ORM","text":"<p>Install Eloquent via Composer:</p> <pre><code>composer require illuminate/database\n</code></pre> <p>Configure and initialize Eloquent:</p> <pre><code>use Illuminate\\Database\\Capsule\\Manager as Capsule;\n\napp()-&gt;container()-&gt;set('db', function () {\n    $capsule = new Capsule;\n    $config = config('database');\n\n    $capsule-&gt;addConnection([\n        'driver'    =&gt; $config['driver'],\n        'host'      =&gt; $config['host'],\n        'database'  =&gt; $config['database'],\n        'username'  =&gt; $config['username'],\n        'password'  =&gt; $config['password'],\n        'charset'   =&gt; $config['charset'],\n        'collation' =&gt; 'utf8mb4_unicode_ci',\n        'prefix'    =&gt; '',\n    ]);\n\n    $capsule-&gt;setAsGlobal();\n    $capsule-&gt;bootEloquent();\n\n    return $capsule;\n});\n</code></pre> <p>Use models as usual:</p> <pre><code>use App\\Models\\User;\n\n$user = User::find(1);\n</code></pre>"},{"location":"external_libraries/#tips-for-integration","title":"Tips for Integration","text":"<ul> <li>Register services inside your container via <code>app()-&gt;container()-&gt;set()</code>.</li> <li>Load config values using <code>config('key')</code>.</li> <li>Keep external libraries isolated and modular.</li> <li>You are free to build your own architecture around NixPHP without restrictions.</li> </ul>"},{"location":"external_libraries/#summary","title":"Summary","text":"<ul> <li>NixPHP allows easy integration of any Composer package.</li> <li>External tools like Blade, Eloquent, or Guzzle work seamlessly.</li> <li>Service registration and configuration stay fully under your control.</li> </ul>"},{"location":"file_downloads/","title":"File Downloads","text":"<p>Sometimes you want to send files to the browser for download instead of displaying them. NixPHP gives you full control to stream files using a custom response.</p>"},{"location":"file_downloads/#downloading-a-file","title":"Downloading a File","text":"<p>You can manually create a response that forces a file download:</p> <pre><code>use function NixPHP\\response;\n\n$filePath = BASE_PATH . '/storage/files/example.pdf';\n$fileName = 'example.pdf';\n\n$response = response(file_get_contents($filePath))\n    -&gt;withHeader('Content-Type', 'application/octet-stream')\n    -&gt;withHeader('Content-Disposition', 'attachment; filename=\"' . $fileName . '\"');\n\nreturn $response;\n</code></pre> <ul> <li><code>Content-Type</code> tells the browser this is a generic file download.</li> <li><code>Content-Disposition: attachment</code> forces the download dialog.</li> <li>The file is loaded into the response body.</li> </ul>"},{"location":"file_downloads/#example-download-controller","title":"Example: Download Controller","text":"<pre><code>namespace App\\Controllers;\n\nuse function NixPHP\\response;\n\nclass FileController\n{\n    public function download($filename)\n    {\n        $path = BASE_PATH . '/storage/files/' . basename($filename);\n\n        if (!file_exists($path)) {\n            abort(404, 'File not found.');\n        }\n\n        return response(file_get_contents($path))\n            -&gt;withHeader('Content-Type', 'application/octet-stream')\n            -&gt;withHeader('Content-Disposition', 'attachment; filename=\"' . basename($filename) . '\"');\n    }\n}\n</code></pre> <ul> <li>Always use <code>basename()</code> to prevent directory traversal attacks.</li> <li>Always check if the file actually exists before sending it.</li> </ul>"},{"location":"file_downloads/#notes","title":"Notes","text":"<ul> <li>For large files, you may want to implement streaming to avoid memory issues.</li> <li>You can adjust <code>Content-Type</code> based on the file type if needed (e.g., <code>application/pdf</code> for PDFs).</li> </ul> <p>Example for PDF:</p> <pre><code>return response(file_get_contents($pdfPath))\n    -&gt;withHeader('Content-Type', 'application/pdf')\n    -&gt;withHeader('Content-Disposition', 'attachment; filename=\"document.pdf\"');\n</code></pre>"},{"location":"file_downloads/#summary","title":"Summary","text":"<ul> <li>Use <code>response(file_get_contents($path))</code> to build file download responses.</li> <li>Always set proper headers (<code>Content-Type</code>, <code>Content-Disposition</code>).</li> <li>Always sanitize filenames to prevent security issues.</li> </ul>"},{"location":"guard/","title":"Guard","text":"<p>NixPHP includes a central <code>Guard</code> class designed to simplify and secure common low-level operations like path validation, output escaping, and CSRF token handling.</p> <p>The <code>Guard</code> focuses on security-by-default, helping to protect your application against common attack vectors such as Local File Inclusion (LFI), Cross-Site Scripting (XSS), and Cross-Site Request Forgery (CSRF).</p> <p>You can access the <code>Guard</code> instance anywhere via the global helper:</p> <pre><code>guard()\n</code></pre>"},{"location":"guard/#features","title":"Features","text":"<p>The <code>Guard</code> provides several safety-focused utilities:</p> Method Purpose <code>guard()-&gt;safePath($path)</code> Validate paths against traversal, stream wrappers, and illegal characters <code>guard()-&gt;safeOutput($value)</code> Escape strings or arrays for safe HTML output <code>guard()-&gt;csrf()</code> Access CSRF token generation and validation"},{"location":"guard/#path-safety-safepath","title":"Path Safety: <code>safePath()</code>","text":"<pre><code>guard()-&gt;safePath('user.profile');\n</code></pre> <p>Validates that a given path: - Is non-empty - Does not contain traversal (<code>..</code>) - Is not an absolute path - Does not contain stream wrappers (<code>://</code>) - Only contains <code>[A-Za-z0-9_/.-]</code> characters</p> <p>\u2705 If the path is unsafe, an <code>InvalidArgumentException</code> is thrown.</p> <p>Typical usage includes view resolution, file loading, and any file system operation that relies on user-provided input.</p>"},{"location":"guard/#output-escaping-safeoutput","title":"Output Escaping: <code>safeOutput()</code>","text":"<pre><code>guard()-&gt;safeOutput('Hello &lt;script&gt;alert(\"xss\")&lt;/script&gt;');\n// Outputs: Hello &amp;lt;script&amp;gt;alert(&amp;quot;xss&amp;quot;)&amp;lt;/script&amp;gt;\n\nguard()-&gt;safeOutput(['title' =&gt; 'My &lt;b&gt;Title&lt;/b&gt;']);\n</code></pre> <ul> <li>If given a string, escapes it for safe HTML output using <code>htmlspecialchars()</code>.</li> <li>If given an array, recursively escapes each element.</li> <li>Always uses <code>UTF-8</code> encoding and <code>ENT_QUOTES</code> mode for maximum compatibility.</li> </ul> <p>\u2705 Protects your templates and outputs against accidental XSS.</p>"},{"location":"guard/#csrf-token-management-csrf","title":"CSRF Token Management: <code>csrf()</code>","text":"<p>The <code>Guard</code> also handles CSRF protection internally. You can generate and validate CSRF tokens easily:</p> <pre><code>$token = guard()-&gt;csrf()-&gt;generate();\n</code></pre> <p>This: - Starts the session (if not already started) - Creates a CSRF token if none exists - Returns the token for use in forms</p> <p>When validating a submitted token:</p> <pre><code>if (!guard()-&gt;csrf()-&gt;validate($_POST['_csrf'] ?? '')) {\n    abort(419, 'Invalid CSRF token');\n}\n</code></pre> <p>\u2705 The CSRF token stays valid across multiple forms and tabs, and only rotates manually (e.g., after login/logout).</p>"},{"location":"guard/#example-usage","title":"\ud83d\udee0 Example Usage","text":"<p>In a form:</p> <pre><code>&lt;form method=\"POST\" action=\"/submit\"&gt;\n    &lt;input type=\"hidden\" name=\"_csrf\" value=\"&lt;?= guard()-&gt;csrf()-&gt;generate() ?&gt;\"&gt;\n    ...\n&lt;/form&gt;\n</code></pre> <p>When processing the request:</p> <pre><code>if (!guard()-&gt;csrf()-&gt;validate($_POST['_csrf'] ?? '')) {\n    abort(419, 'Invalid CSRF token');\n}\n</code></pre>"},{"location":"guard/#summary","title":"Summary","text":"<ul> <li>The <code>Guard</code> protects your application at critical input/output boundaries.</li> <li>It validates file paths safely, preventing file inclusion vulnerabilities.</li> <li>It escapes output to prevent XSS without needing a full template engine.</li> <li>It handles CSRF token generation and validation automatically and securely.</li> <li>It is available globally via <code>guard()</code> for minimal boilerplate.</li> </ul> <p>\u2705 Best practice: Always validate external input through <code>guard()</code> before using it in filesystem operations or rendering dynamic output.</p>"},{"location":"installation/","title":"Installation","text":"<p>NixPHP is designed as a lightweight framework package. You install it into your own project using Composer.</p>"},{"location":"installation/#install-via-composer","title":"Install via Composer","text":"<pre><code>composer require nixphp/framework\n</code></pre> <p>This will:</p> <ul> <li>Download the NixPHP core (framework logic inside <code>/src</code>)</li> <li>Make it available via Composer autoloading</li> <li>Allow you to use NixPHP components in your own project structure</li> </ul>"},{"location":"installation/#set-up-your-project-structure","title":"Set up your project structure","text":"<p>NixPHP leaves the project organization completely up to you. A typical structure could look like this:</p> <pre><code>/app\n    /Controllers\n    /Models\n    /Views\n    config.php\n    routes.php\n/public\n    index.php\nbootstrap.php\ncomposer.json\n</code></pre> <p>But you are free to organize it however you like.</p>"},{"location":"installation/#first-steps","title":"First Steps","text":"<p>You typically:</p> <ul> <li>Create a <code>bootstrap.php</code> to initialize NixPHP</li> <li>Set up your <code>routes.php</code></li> <li>Create a <code>public/index.php</code> as your web entry point</li> </ul> <p>Example:</p> <pre><code>// /bootstrap.php\n\ndefine('BASE_PATH', __DIR__);\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\nuse function NixPHP\\app;\n\napp()-&gt;run(); // Start the application\n</code></pre>"},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>PHP 8.3 or higher</li> <li>Composer</li> </ul>"},{"location":"plugins/","title":"Plugins","text":"<p>NixPHP includes a clean and lightweight plugin system that allows you to extend the framework with zero configuration.</p> <p>Plugins can provide additional configuration, templates (views), and custom logic via a <code>bootstrap.php</code> file. Once a plugin is installed via Composer, it is automatically detected and integrated.</p>"},{"location":"plugins/#plugin-structure","title":"Plugin Structure","text":"<p>A NixPHP plugin mimics the structure of a full app:</p> <pre><code>your-plugin/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 config.php         // Plugin-specific configuration\n\u2502   \u2514\u2500\u2500 views/             // Plugin-specific templates\n\u2502       \u2514\u2500\u2500 example.phtml\n\u251c\u2500\u2500 bootstrap.php          // Bootstrap logic (routes, events, services, etc.)\n\u2514\u2500\u2500 composer.json\n</code></pre> <ul> <li><code>app/config.php</code> is merged into the global config.</li> <li><code>app/views/</code> is added to the view resolver.</li> <li><code>bootstrap.php</code> is automatically executed when the plugin is discovered.</li> </ul>"},{"location":"plugins/#example-composerjson","title":"\ud83d\udee0 Example <code>composer.json</code>","text":"<p>Below is a minimal but complete <code>composer.json</code> for a NixPHP plugin:</p> <pre><code>{\n  \"name\": \"vendor/NixPHP-plugin-example\",\n  \"description\": \"Skeleton for your first plugin when using NixPHP\",\n  \"type\": \"NixPHP-plugin\",\n  \"license\": \"MIT\",\n  \"authors\": [\n    {\n      \"name\": \"Your Name\",\n      \"email\": \"your@mail.com\"\n    }\n  ],\n  \"require\": {\n    \"php\": \"&gt;=8.3\",\n    \"fkde/NixPHP\": \"dev-main\"\n  },\n  \"autoload\": {\n    \"psr-4\": {\n      \"MyPlugin\\\\\": \"app/\"\n    }\n  },\n  \"minimum-stability\": \"stable\",\n  \"prefer-stable\": true\n}\n</code></pre> <p>\u2705 Important: - <code>\"type\": \"NixPHP-plugin\"</code> is required for discovery. - The namespace (e.g. <code>MyPlugin\\\\</code>) must match your plugin classes location.</p> <p>Run:</p> <pre><code>composer dump-autoload\n</code></pre> <p>To ensure your classes are properly registered.</p>"},{"location":"plugins/#automatic-discovery","title":"Automatic Discovery","text":"<p>Plugins are discovered via Composer using the package <code>\"type\": \"NixPHP-plugin\"</code>. Once installed, NixPHP will:</p> <ul> <li>Load <code>bootstrap.php</code></li> <li>Merge <code>app/config.php</code></li> <li>Register all <code>app/views/</code> templates</li> </ul> <p>No manual registration is needed.</p>"},{"location":"plugins/#accessing-plugin-metadata","title":"Accessing Plugin Metadata","text":"<pre><code>plugin()-&gt;getMeta('viewPaths');\nplugin()-&gt;getMeta('configPaths');\nplugin()-&gt;getMeta('bootstraps');\n</code></pre> <p>For internal use or debugging only \u2013 no need to register anything yourself.</p>"},{"location":"plugins/#example-plugin-error-views","title":"Example Plugin: Error Views","text":"<pre><code>my-error-plugin/\n\u251c\u2500\u2500 app/\n\u2502   \u2514\u2500\u2500 views/\n\u2502       \u2514\u2500\u2500 errors/\n\u2502           \u251c\u2500\u2500 404.phtml\n\u2502           \u2514\u2500\u2500 500.phtml\n\u2514\u2500\u2500 bootstrap.php\n</code></pre> <p>Usage:</p> <pre><code>render('errors.404');\n</code></pre>"},{"location":"plugins/#example-plugin-routing-to-a-controller","title":"Example Plugin: Routing to a Controller","text":"<p>Structure:</p> <pre><code>my-hello-plugin/\n\u251c\u2500\u2500 app/\n\u2502   \u2514\u2500\u2500 Controllers/\n\u2502       \u2514\u2500\u2500 HelloController.php\n\u251c\u2500\u2500 bootstrap.php\n\u2514\u2500\u2500 composer.json\n</code></pre> <p>HelloController.php:</p> <pre><code>namespace MyHelloPlugin\\Controllers;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse function NixPHP\\response;\n\nclass HelloController\n{\n    public function index(): ResponseInterface\n    {\n        return response('Hello from the plugin controller!');\n    }\n}\n</code></pre> <p>bootstrap.php:</p> <pre><code>use MyHelloPlugin\\Controllers\\HelloController;\nuse function NixPHP\\route;\n\nroute()-&gt;add('GET', '/plugin-hello', [HelloController::class, 'index']);\n</code></pre> <p>Visit: <code>http://yourapp.local/plugin-hello</code></p>"},{"location":"plugins/#view-resolution-order","title":"View Resolution Order","text":"<ol> <li>App <code>app/views/</code></li> <li>Plugins <code>plugin/app/views/</code></li> <li>Framework <code>core/Resources/views/</code></li> </ol>"},{"location":"plugins/#config-merge-order","title":"Config Merge Order","text":"<ol> <li>App <code>app/config.php</code></li> <li>Plugins <code>app/config.php</code></li> <li>Framework <code>src/config.php</code></li> </ol>"},{"location":"plugins/#summary","title":"Summary","text":"<ul> <li>Plugins mimic the structure of the main app (<code>app/config.php</code>, <code>app/views/</code>, <code>Controllers/</code>)</li> <li>Auto-loaded by Composer if <code>\"type\": \"NixPHP-plugin\"</code> is set</li> <li>Can register routes, logic, templates, config \u2013 with no extra steps</li> <li>Can be overridden by the app cleanly</li> <li><code>plugin()</code> helper gives access to metadata for advanced use</li> </ul>"},{"location":"response_handling/","title":"Response Handling","text":"<p>In NixPHP, every route must return a valid HTTP response that implements <code>Psr\\Http\\Message\\ResponseInterface</code>.</p> <p>To make this easy, NixPHP provides global helper functions for generating different types of responses.</p>"},{"location":"response_handling/#the-response-helper","title":"The response() Helper","text":"<p>The <code>response()</code> function creates a simple HTTP response with a body.</p> <pre><code>use function NixPHP\\response;\n\nreturn response('Hello World');\n</code></pre> <ul> <li>Accepts a string for plain text or HTML content.</li> <li>Sets the <code>Content-Type</code> header to <code>text/html; charset=UTF-8</code> by default.</li> </ul> <p>Important: If you want to send JSON data, you must use the <code>json()</code> helper explicitly.</p>"},{"location":"response_handling/#the-json-helper","title":"The json() Helper","text":"<p>Use the <code>json()</code> helper to create a proper JSON HTTP response:</p> <pre><code>use function NixPHP\\json;\n\nreturn json(['message' =&gt; 'Success']);\n</code></pre> <ul> <li>Serializes the given array or object to JSON.</li> <li>Sets the <code>Content-Type</code> header to <code>application/json; charset=UTF-8</code>.</li> <li>Allows you to optionally set a custom status code.</li> </ul> <p>Example with a custom status:</p> <pre><code>return json(['error' =&gt; 'Unauthorized'], 401);\n</code></pre>"},{"location":"response_handling/#the-render-helper","title":"The render() Helper","text":"<p>Use the <code>render()</code> helper to render a view and return it wrapped in a response:</p> <pre><code>use function NixPHP\\render;\n\nreturn render('home', ['name' =&gt; 'World']);\n</code></pre> <ul> <li>Loads the specified view from <code>app/views/</code> using dot notation.</li> <li>Escapes variables safely using <code>s()</code>.</li> <li>Wraps the output into a <code>text/html</code> response.</li> </ul>"},{"location":"response_handling/#redirect-responses","title":"Redirect Responses","text":"<p>You can create a redirect response using the <code>redirect()</code> helper:</p> <pre><code>use function NixPHP\\redirect;\n\nreturn redirect('/login');\n</code></pre> <ul> <li>Sends a 302 redirect by default.</li> <li>Optionally, you can specify a different HTTP status code (e.g., 301).</li> </ul> <p>Example:</p> <pre><code>return redirect('/dashboard', 301);\n</code></pre>"},{"location":"response_handling/#custom-responses","title":"Custom Responses","text":"<p>For full control, you can manually create responses:</p> <pre><code>$response = new \\NixPHP\\Http\\Response();\n$response-&gt;getBody()-&gt;write('Custom content');\nreturn $response-&gt;withStatus(202);\n</code></pre> <ul> <li>Set custom headers, status codes, and body manually.</li> <li>Useful for advanced use cases or non-standard responses.</li> </ul>"},{"location":"response_handling/#summary","title":"Summary","text":"<ul> <li>Use <code>response(string)</code> for plain text or HTML.</li> <li>Use <code>json(array|object)</code> for JSON API responses.</li> <li>Use <code>render(view, variables)</code> to return rendered HTML views.</li> <li>Use <code>redirect(url, status)</code> to redirect users to another page.</li> <li>Always return a valid PSR-7 Response.</li> </ul>"},{"location":"routing/","title":"Routing","text":"<p>NixPHP provides a simple and powerful routing system based on HTTP methods and URIs. Routes map incoming requests to controller methods or closures with minimal configuration.</p>"},{"location":"routing/#defining-routes","title":"Defining Routes","text":"<p>Routes are defined inside the <code>app/routes.php</code> file.</p> <p>Example:</p> <pre><code>// app/routes.php\n\nroute()-&gt;add('GET', '/hello', [HelloController::class, 'index']);\n</code></pre> <ul> <li><code>'GET'</code> \u2192 HTTP method (<code>'POST'</code>, <code>'PUT'</code>, <code>'DELETE'</code>, etc. are also supported)</li> <li><code>'/hello'</code> \u2192 URL path</li> <li><code>[HelloController::class, 'index']</code> \u2192 Controller and method to handle the request</li> </ul>"},{"location":"routing/#using-closures","title":"Using Closures","text":"<p>You can also define a route with a closure instead of a controller:</p> <pre><code>// app/routes.php\n\nroute()-&gt;add('GET', '/ping', function () {\n    // Handle the request here\n});\n</code></pre> <ul> <li>Useful for small endpoints, prototypes, or quick tests.</li> </ul>"},{"location":"routing/#route-parameters","title":"Route Parameters","text":"<p>Dynamic URL segments can be defined using <code>{}</code>:</p> <pre><code>// app/routes.php\n\nroute()-&gt;add('GET', '/user/{id}', [UserController::class, 'show']);\n</code></pre> <p>In the controller:</p> <pre><code>namespace App\\Controllers;\n\nclass UserController\n{\n    public function show($id)\n    {\n        // $id contains the value from the URL\n    }\n}\n</code></pre> <ul> <li>Route parameters are automatically passed to your controller method or closure.</li> <li>The order of placeholders matches the method's parameters.</li> </ul>"},{"location":"routing/#supported-http-methods","title":"Supported HTTP Methods","text":"<p>NixPHP supports all standard HTTP methods:</p> <ul> <li><code>GET</code></li> <li><code>POST</code></li> <li><code>PUT</code></li> <li><code>PATCH</code></li> <li><code>DELETE</code></li> <li>(others like <code>OPTIONS</code> or <code>HEAD</code> are also possible)</li> </ul>"},{"location":"sessions/","title":"Session","text":"<p>NixPHP provides a minimal but powerful session management system. You can easily work with session data, flash messages, and session control.</p> <p>Sessions are only started manually when you actually need them.</p>"},{"location":"sessions/#starting-a-session","title":"Starting a Session","text":"<p>To start the PHP session, use the <code>session()</code> helper:</p> <pre><code>use function NixPHP\\session;\n\nsession()-&gt;start();\n</code></pre> <ul> <li>This starts <code>$_SESSION</code> if not already active.</li> <li>You control exactly when session management begins.</li> </ul>"},{"location":"sessions/#setting-and-getting-session-data","title":"Setting and Getting Session Data","text":"<p>Set a session value:</p> <pre><code>session()-&gt;set('user_id', 42);\n</code></pre> <p>Retrieve a session value:</p> <pre><code>$userId = session()-&gt;get('user_id');\n</code></pre> <p>Retrieve a value with a default fallback:</p> <pre><code>$language = session()-&gt;get('language', 'en');\n</code></pre>"},{"location":"sessions/#flash-messages","title":"Flash Messages","text":"<p>Flash messages are stored temporarily and removed after the next access. Useful for one-time notifications like success or error messages.</p> <p>Set a flash message:</p> <pre><code>session()-&gt;flash('success', 'Your profile has been updated.');\n</code></pre> <p>Retrieve and automatically delete a flash message:</p> <pre><code>$successMessage = session()-&gt;getFlash('success');\n</code></pre> <ul> <li>After calling <code>getFlash()</code>, the flash value is deleted automatically.</li> <li>If no flash message is found, the optional default value is returned.</li> </ul>"},{"location":"sessions/#forgetting-session-data","title":"Forgetting Session Data","text":"<p>To manually remove a value from the session:</p> <pre><code>session()-&gt;forget('user_id');\n</code></pre> <ul> <li>Useful for logging out users or cleaning up session data manually.</li> </ul>"},{"location":"sessions/#summary","title":"Summary","text":"<ul> <li>Sessions are manually started via <code>session()-&gt;start()</code>.</li> <li>Set and retrieve session data easily.</li> <li>Flash messages are built in via <code>flash()</code> and <code>getFlash()</code>.</li> <li>Sessions remain under your full control \u2014 only active when you want them.</li> </ul>"},{"location":"views/","title":"Views","text":"<p>NixPHP comes with a lightweight native view system. It provides simple template inheritance, layout usage, and reusable content blocks \u2014 without needing a heavy engine like Blade or Twig.</p>"},{"location":"views/#rendering-a-view","title":"Rendering a View","text":"<p>You can render a view file using the <code>render()</code> helper function:</p> <pre><code>use function NixPHP\\render;\n\nreturn render('hello', ['name' =&gt; 'World']);\n</code></pre> <ul> <li>The first argument is the view name (relative to the <code>app/views/</code> folder, using dot notation).</li> <li>The second argument is an optional array of variables to pass into the view.</li> <li><code>render()</code> automatically wraps the view in a proper Response object.</li> </ul> <p>This will load <code>app/views/hello.phtml</code>.</p>"},{"location":"views/#view-files","title":"View Files","text":"<p>View files are simple PHP templates with <code>.phtml</code> extension.</p> <p>Example: <code>app/views/hello.phtml</code></p> <pre><code>&lt;?php use function NixPHP\\s; ?&gt;\n\n&lt;h1&gt;Hello, &lt;?= s($name) ?&gt;!&lt;/h1&gt;\n</code></pre> <ul> <li>Use the <code>s()</code> helper to safely escape variables for HTML output.</li> </ul>"},{"location":"views/#layouts","title":"Layouts","text":"<p>You can create a layout and attach it to your view using <code>setLayout()</code>.</p> <p>Example: <code>app/views/layouts/main.phtml</code></p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;&lt;?= $this-&gt;renderBlock('title', 'NixPHP App') ?&gt;&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;?= $this-&gt;renderBlock('content') ?&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>In your view:</p> <pre><code>&lt;?php use function NixPHP\\s; ?&gt;\n\n&lt;?php $this-&gt;setLayout('layouts.main') ?&gt;\n\n&lt;?php $this-&gt;block('title') ?&gt;\nHello Page\n&lt;?php $this-&gt;endblock('title') ?&gt;\n\n&lt;?php $this-&gt;block('content') ?&gt;\n&lt;h1&gt;Hello, &lt;?= s($name) ?&gt;!&lt;/h1&gt;\n&lt;?php $this-&gt;endblock('content') ?&gt;\n</code></pre> <ul> <li><code>setLayout('layouts.main')</code> specifies the layout file (dot notation).</li> <li><code>block('name')</code> and <code>endblock('name')</code> define a section.</li> <li><code>renderBlock('name')</code> renders the defined blocks into the layout.</li> </ul>"},{"location":"views/#variables-in-views","title":"Variables in Views","text":"<p>All variables passed to <code>render()</code> are automatically extracted into the view.</p> <p>Example:</p> <pre><code>return render('profile', ['user' =&gt; $user]);\n</code></pre> <p>In <code>app/views/profile.phtml</code>:</p> <pre><code>&lt;?php use function NixPHP\\s; ?&gt;\n\n&lt;h2&gt;Welcome, &lt;?= s($user['name']) ?&gt;!&lt;/h2&gt;\n</code></pre>"},{"location":"views/#rendering-views-without-a-response","title":"Rendering Views without a Response","text":"<p>Sometimes you only need the raw HTML output of a view without wrapping it in a full Response object. For this, you can use the <code>view()</code> helper:</p> <pre><code>use function NixPHP\\view;\n\n$html = view('hello', ['name' =&gt; 'World']);\n</code></pre> <ul> <li><code>view()</code> returns the rendered HTML as a plain string.</li> <li>It does not create a Response object.</li> <li>Useful for building custom responses or templates manually.</li> </ul>"},{"location":"views/#summary","title":"Summary","text":"<ul> <li>Views are located in <code>app/views/</code>.</li> <li>Use dot notation when referencing views (e.g., <code>layouts.main</code>).</li> <li>Use <code>setLayout()</code> to attach layouts inside views.</li> <li>Use <code>s()</code> to escape variables.</li> <li>Use <code>render()</code> for full responses and <code>view()</code> for raw HTML output.</li> </ul>"}]}